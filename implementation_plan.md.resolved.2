# Fabric Consumption Estimator Implementation Plan

## Goal Description
Build a single-file Streamlit application ([app.py](file:///Users/jagdishs/.gemini/antigravity/scratch/fabric-estimator/app.py)) that calculates fabric consumption from VStitcher pattern PDFs. The app will extract vector paths from uploaded PDFs, calculate their area, and estimate fabric yield based on a configurable width and waste factor.

## Proposed Changes

### Configuration
#### [NEW] [requirements.txt](file:///Users/jagdishs/.gemini/antigravity/scratch/fabric-estimator/requirements.txt)
- `streamlit`
- `pymupdf` (imported as `fitz`)
- `shapely`
- `pandas`
- `openpyxl` (for Excel export)

### Application Logic
#### [NEW] [app.py](file:///Users/jagdishs/.gemini/antigravity/scratch/fabric-estimator/app.py)
- **Imports**: `streamlit`, `fitz`, `shapely.geometry`, `pandas`, `io`.
- **Sidebar**:
    - `st.sidebar.number_input` for "Fabric Width (cm)".
- **Core Function `extract_pattern_area(uploaded_file)`**:
    - Open PDF from stream using `fitz.open(stream=..., filetype="pdf")`.
    - Iterate through pages.
    - Use `page.get_drawings()` to find paths.
    - Convert paths to Shapely `Polygon` objects.
        - Handle Bezier curves if necessary (simple approximation or bounding box might be needed, but `get_drawings` returns items that can be converted to points).
        - *Self-Correction*: `pymupdf` drawings can be complex. We will approximate area by converting closed paths to polygons. If paths are just lines, we might need a convex hull or simply sum the areas of closed path items. Given "VStitcher pattern PDFs", these are usually vector outlines. We will assume closed paths represent pattern pieces.
    - Sum the area of all polygons.
    - Return total area in $m^2$ (handling unit conversion from PDF points to meters).
        - PDF points are usually 1/72 inch.
        - 1 point = 0.0352778 cm.
        - 1 point = 0.000352778 m.
        - Area in points^2 * (0.000352778)^2 = Area in m^2.
- **Main UI**:
    - `st.file_uploader` (accept_multiple_files=True).
    - Loop through files, call `extract_pattern_area`.
    - Calculate Yield: $(Area * 1.15) / (Width\_cm / 100)$.
    - Store results in a list of dicts.
    - Create DataFrame.
    - Display DataFrame with `st.dataframe`.
    - `st.download_button` for Excel export.

### Version 2.4 Specification (Costing & DXF)
#### Costing Logic
- **UI**: Add `st.number_input("Cost per Meter", ...)` inside the Fabric & Marker expander.
- **Calculation**: `Total Cost = Marker Length (m) * Cost per Meter`.
- **Display**: Add a metric card for "Estimated Cost".
- **Export**: Add "Unit Cost" and "Total Cost" columns/cells to the Excel "Summary" sheet.

#### DXF Import Logic
- **Upload**: Update `st.file_uploader` to type `["pdf", "dxf"]`.
- **Parsing**: Create [extract_polygons_from_dxf(file_stream)](file:///Users/jagdishs/.gemini/antigravity/scratch/fabric-estimator/app.py#65-141):
    - Use `ezdxf.read(file_stream)`.
    - Iterate `MSP` (Modelspace).
    - Query `LWPOLYLINE` and `POLYLINE` entities.
    - Extract points [(x, y)](file:///Users/jagdishs/.gemini/antigravity/scratch/fabric-estimator/app.py#196-216).
    - **Scaling**: DXF is often unitless. We will assume millimeters (common in apparel) or check `$INSUNITS`.
    - **UI**: Add a radio button "DXF Import Units" (mm, cm, inch) to let user verify. Default to `mm`.
    - Convert all to internal points (like PDF) or standardize on CM immediately for the packer.
        - *Decision*: Convert everything to **Points** to match existing PDF logic (1 pt = 1/72 inch) or refactor app to work linearly in CM.
        - *Simpler Approach*: Convert incoming DXF coords -> CM -> Points.
        - 1 mm = 2.83465 points.
        - 1 cm = 28.3465 points.
        - 1 inch = 72 points.
    - Return list of Shapely Polygons.

### Version 2.5 Specification (Smart Rotation)
#### Minimum Area Logic
- **Goal**: Minimize waste by finding the optimal rotation for *each* piece that results in the smallest Rectangular Bounding Box.
- **Constraints**: This changes the grainline. It must be an **Optional Setting** (checkbox: "Auto-Align to Grain (Min Bounding Box)").
- **Implementation**:
    1.  Create helper `get_min_area_rotation_angle(poly)`.
    2.  Use `shapely.minimum_rotated_rectangle(poly)` to get the tightest box.
    3.  Calculate the angle of that box's long edge relative to X-axis.
    4.  Rotate the polygon by `-angle`.
    5.  **Integration**: In the packing loop, if checkbox is checked, apply this rotation *before* standard grainline rotation or packing logic.
    - *Note*: Usually, if this is enabled, it *overrides* standard "Length/Cross" file settings because it claims to find the "True" grain alignment (assuming the piece's bounding box aligns with grain).

## Verification Plan
### Automated Tests
- I cannot easily run automated UI tests for Streamlit in this environment.
- I will verify the logic by ensuring the code assumes 72 DPI (standard PDF) unless coordinates suggest otherwise.

### Manual Verification
- Code review of the area calculation logic.
- Ensure all imports are present.
